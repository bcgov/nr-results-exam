name: .Deploys

on:
  workflow_call:
    inputs:
      ### Required
      redirect_url:
        description: Frontend redirect from URL
        required: true
        type: string
      tag:
        description: Container tag; usually PR number
        required: true
        type: string
      zone:
        description: Deployment zone, e.g. pr-###, test or prod
        required: true
        type: string

      ### Optional
      environment:
        description: GitHub/OpenShift environment; usually PR number, test or prod
        default: ""
        type: string
      report_issue:
        description: Create an issue when deployment fails
        default: false
        type: boolean
      run_smoke_tests:
        description: Run smoke tests after deployment
        default: true
        type: boolean
      frontend_url:
        description: Frontend URL for smoke tests (auto-calculated if not provided)
        required: false
        type: string

    secrets:
      ches_client_secret:
        description: CHES client secret
        required: true
      oc_token:
        description: OpenShift token
        required: true
      s3_secretkey:
        description: S3 secret key
        required: true

jobs:
  init:
    name: Init and calculate deployment parameters
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-24.04
    timeout-minutes: 1
    permissions:
      contents: read
    outputs:
      mod_zone: ${{ steps.mod-zone.outputs.mod_zone }}
    steps:
      - name: Deploy OpenShift init resources
        uses: bcgov/action-deployer-openshift@v4.0.1
        with:
          file: common/openshift.init.yml
          oc_namespace: ${{ vars.OC_NAMESPACE }}
          oc_server: ${{ vars.OC_SERVER }}
          oc_token: ${{ secrets.oc_token }}
          parameters: -p ZONE=${{ inputs.zone }}
            -p CHES_CLIENT_SECRET=${{ secrets.ches_client_secret }}
            -p S3_SECRETKEY=${{ secrets.s3_secretkey }}
            -p VITE_USER_POOLS_WEB_CLIENT_ID=${{ vars.VITE_USER_POOLS_WEB_CLIENT_ID }}

      - name: Calculate MOD_ZONE
        id: mod-zone
        run: |
          # For PR deployments (numeric zones), calculate modulo 50
          # For named environments (test, prod), use the zone as-is
          if [[ "${{ inputs.zone }}" =~ ^[0-9]+$ ]]; then
            echo "mod_zone=$(( ${{ inputs.zone }} % 50 ))" >> $GITHUB_OUTPUT
          else
            echo "mod_zone=${{ inputs.zone }}" >> $GITHUB_OUTPUT
          fi

  deploys:
    name: Deploy
    needs: [init]
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    permissions:
      contents: read
    strategy:
      matrix:
        name: [backend, frontend]
    steps:
      - uses: bcgov/action-deployer-openshift@v4.0.1
        id: deploys
        with:
          file: ${{ matrix.name }}/openshift.deploy.yml
          oc_namespace: ${{ vars.OC_NAMESPACE }}
          oc_server: ${{ vars.OC_SERVER }}
          oc_token: ${{ secrets.oc_token }}
          parameters: -p ZONE=${{ inputs.zone }}
            -p TAG=${{ inputs.tag }}
            -p MOD_ZONE=${{ needs.init.outputs.mod_zone }}
            ${{ matrix.name == 'frontend' && format('-p REDIRECT_URL={0}', inputs.redirect_url) || '' }}

  smoke:
    name: Smoke Tests
    if: inputs.run_smoke_tests == true
    needs: [init, deploys]
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - name: Calculate frontend URL
        id: frontend-url
        run: |
          if [ -n "${{ inputs.frontend_url }}" ]; then
            # Use provided frontend URL
            echo "url=${{ inputs.frontend_url }}" >> $GITHUB_OUTPUT
          else
            # Calculate from zone (for PRs)
            DOMAIN="apps.silver.devops.gov.bc.ca"
            REPO="nr-results-exam"
            MOD_ZONE="${{ needs.init.outputs.mod_zone }}"
            echo "url=https://${REPO}-${MOD_ZONE}-frontend.${DOMAIN}" >> $GITHUB_OUTPUT
          fi

      - uses: actions/checkout@v6
      
      - uses: actions/setup-node@v6
        with:
          node-version: "24"

      - name: Run smoke tests
        working-directory: integration-tests
        env:
          FRONTEND_URL: ${{ steps.frontend-url.outputs.url }}
          REDIRECT_URL: ${{ inputs.redirect_url && format('https://{0}', inputs.redirect_url) || '' }}
        run: |
          npm ci
          npm run smoke

  report-failures:
    name: Failure Reporting
    if: ${{ inputs.report_issue && always() && (needs.init.result == 'failure' || needs.deploys.result == 'failure' || (inputs.run_smoke_tests && needs.smoke.result == 'failure')) }}
    # Include all needs that could have failures!
    # Note: smoke is conditional - if skipped, report-failures will also be skipped
    # but we check smoke result only if run_smoke_tests is true
    needs: [init, deploys, smoke]
    runs-on: ubuntu-24.04
    permissions:
      issues: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 1 # Shallow clone since we only need CODEOWNERS

      - name: Find CODEOWNERS file
        id: find-codeowners
        run: |
          # Find CODEOWNERS file case-insensitively in GitHub-recognized locations
          # GitHub searches in order: root, .github/, docs/ (use first found)
          CODEOWNERS_PATH=""
          # Check root first
          if [ -z "$CODEOWNERS_PATH" ]; then
            CODEOWNERS_PATH=$(find . -maxdepth 1 -type f -iname "codeowners*" -not -path "*/\.git/*" 2>/dev/null | head -1)
          fi
          # Then .github/
          if [ -z "$CODEOWNERS_PATH" ]; then
            CODEOWNERS_PATH=$(find .github -maxdepth 1 -type f -iname "codeowners*" 2>/dev/null | head -1)
          fi
          # Finally docs/
          if [ -z "$CODEOWNERS_PATH" ]; then
            CODEOWNERS_PATH=$(find docs -maxdepth 1 -type f -iname "codeowners*" 2>/dev/null | head -1)
          fi
          if [ -n "$CODEOWNERS_PATH" ]; then
            echo "path=$CODEOWNERS_PATH" >> $GITHUB_OUTPUT
            echo "Found CODEOWNERS at: $CODEOWNERS_PATH"
          else
            echo "No CODEOWNERS file found"
          fi

      - name: Report Results
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const zone = '${{ inputs.zone }}';
            const workflowUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const title = `ci(deploy): deployment failed in ${zone}`;
            const body = `âŒ Deployment to **${zone}** zone failed.\n\n[View workflow run](${workflowUrl})`;

            // Read CODEOWNERS file to get assignees
            let assignees = [];
            const codeownersPath = `${{ steps.find-codeowners.outputs.path }}`.trim();

            if (codeownersPath) {
              try {
                const codeownersContent = fs.readFileSync(codeownersPath, 'utf8');
                // Filter out comment lines (lines starting with #) and empty lines
                const lines = codeownersContent.split('\n')
                  .map(line => line.trim())
                  .filter(line => line && !line.startsWith('#'));
                
                // Extract usernames from CODEOWNERS (format: * @username or path @username)
                // Match both users (@username) and teams (@org/team-name)
                // GitHub usernames must start/end with alphanumeric, can contain hyphens/underscores in middle
                // NOTE: This intentionally extracts all usernames across all lines, regardless of path patterns.
                // This ensures deployment failures are visible to all repository maintainers, not just path-specific owners.
                const usernameMatches = lines.join('\n').match(/@([a-zA-Z0-9](?:[a-zA-Z0-9_-]*[a-zA-Z0-9])?(?:\/[a-zA-Z0-9](?:[a-zA-Z0-9_-]*[a-zA-Z0-9])?)?)/g);
                if (usernameMatches) {
                  // Remove '@', filter out team references (those containing '/')
                  // Teams cannot be assigned to issues, only individual users
                  assignees = [...new Set(usernameMatches
                    .map(m => m.substring(1))
                    .filter(name => !name.includes('/'))
                  )];
                }
              } catch (error) {
                console.log(`Could not read or parse CODEOWNERS: ${error.message}`);
              }
            } else {
              console.log('No CODEOWNERS file found - issue will be created without assignees');
            }

            // GitHub Issues API limits assignees to 10 per issue
            const maxAssignees = 10;
            const assigneesToUse = assignees.slice(0, maxAssignees);
            if (assignees.length > maxAssignees) {
              console.log(`Warning: ${assignees.length} assignees found, limiting to first ${maxAssignees}`);
            }

            try {
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                assignees: assigneesToUse
              });
              console.log(`Created issue #${issue.data.number} for deployment failure${assigneesToUse.length > 0 ? ` (assigned to: ${assigneesToUse.join(', ')})` : ''}`);
            } catch (error) {
              // If assignment fails due to permissions, retry without assignees but mention them
              if (error.status === 422 || (error.response && error.response.status === 422)) {
                const bodyWithMentions = `${body}\n\ncc: ${assigneesToUse.map(u => `@${u}`).join(' ')}`;
                try {
                  const issue = await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: title,
                    body: bodyWithMentions
                  });
                  console.log(`Created issue #${issue.data.number} (mentioned: ${assigneesToUse.join(', ')})`);
                } catch (retryError) {
                  core.error(`Could not create issue: ${retryError.message}`);
                }
              } else {
                core.error(`Could not create issue: ${error.message}`);
              }
            }
